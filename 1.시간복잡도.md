# 시간복잡도
* 문제 해결까지 시간이 얼마나 걸릴지 시간을 예측.
* 시간 복잡도를 이용하면 작성한 코드가 시간이 대략 얼마인지 예측
* 표기법으로 대문자 O를 사용한다.
* 영어로는 Big O Notation
* 입력의 크기 N에 대해서 시간이 얼마나 걸릴지 나타내는 방법
* 즉, 최악의 경우에 시간이 얼마나 걸릴지 알 수 있다.

#### 시간 복잡도는 소스를 보고 계산할 수도 있고, 소스를 작성하기 전에 먼저 계산해볼 수 있다.
#### 문제를 풀기 전에 먼저 생각한 방법의 시간 복잡도를 계산해보고 이게 시간 안에 수행될 것 같은 경우에 수행하는 것이 좋다.

### 시간 복잡도 예시
* 총 N명의 사람이 식당에 방문했다.
* 식당에는 메뉴가 M개 있고, 메뉴판이 1개 있다.
* 사람 1명이 메뉴판을 읽는데 걸리는 시간은 O(M)이다.
* 주문한 모든 메뉴는 동시에 나왔고, 각 사람 i가 식사를 하는데 걸리는 시간은 A(i)이다.
* 각 사람이 계산을 하는데 걸리는 시간은 O(P)이다.
* 각 사람이 메뉴판에 있는 모든 메뉴를 읽는 시간 복잡도 = O(NM)
* 모든 사람이 식사를 마치는데 걸리는 시간 = O(max(A(i)))
* 식사를 모두 마친 다음 한 줄로 서서 각자 계산을 하는 시간 복잡도 = O(NP)

~~~~~~
int sum = 0;
for (int i=1; i<N; i++){
  sum += i;
 }
~~~~~~
답 : O(N)
~~~~~~
int sum = 0;
for(int i =1; i <=N; i ++){
  for (int j=1; j<=N; j++) {
      if(i == j){
        sum += j;
        }
     }
  }
~~~~~~
답 : O(N^2)

~~~~~~
int sum = 0;
sum = N*(N+1)/2;
~~~~~~
답 : O(1)

* 입력할 수 있는 값에 넣을 수 있는 가장 큰 값을 넣어본다.
* 시간 복잡도 안에 가장 큰 입력 범위를 넣었을 때, 1억이 1초정도이다.

### 시간복잡도계산
* Big O Notation에서 상수는 버린다.
* 두 가지 항이 있을 때, 변수가 같으면 큰 것만 빼고 다 버린다.
* 두 가지 변수의 값을 알 수 없을때는 그래도 나둔다.

### 사용한 메모리
* 보통 가장 많은 공간을 사용하는 것은 보통 배열이다.
* 배열이 사용한 공간 : 배열의크기 X 자료형의 크기 B
* 보통 배열의 크기가 크면 시간 초과를 받는 경우가 많다.
* 불필요한 공간이 없다면, 대부분 메모리 제한은 알아서 지켜진다.

## 입출력
### C입출력
* C의 경우에는 scanf/printf 를 사용할 수 있다.
### C++입출력
* C++경우에는 scanf/print,cin,cout을 사용할 수 있다.
* 입/출력이 많은 문제인 경우에는  scanf/printf 사용
* cin/cout은 scanf/printf 보다 속도가 느리다.

### Java입출력
* Java는 입력은 Scanner, 출력은 System.out을 사용한다.
* Scanner sc = new Scanner(System.in);
* 입력이 많은 경우에는 속도가 느리기 때문에, BufferedReader 를 사용한다.
* BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
* 출력이 많은 경우에는 StringBuilder를 사용해서 한 문자열로 만들어서 출력을 한 번만 사용하거나 BufferedWriter를 사용한다.

