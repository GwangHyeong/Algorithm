## 수학

### 나머지 연산
* 컴퓨터의 정수는 저장할 수 있는 범위가 저장되어 있기 때문에, 답을 M으로 나눈 나머지를 출력하라는 문제가 등장한다.
* 음수일 경우 결과의 부호가 프로그래밍 언어마다 다르다.

### 최대공약수
* 최대공약수는 줄여서 GCD라고 쓴다.
* 두 수 A와 B의 최대공약수는 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.
* 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A,B)까지 모든 정수로 나누어 보는 방법
* 최대공약수가 1인 두 수를 서로소(Coprime)라고 한다.
~~~~~~
int g = 1;
for (int i=2; i<min(a,b); i++) {
  if (a % i == 0 && b % i == 0) {
      g = i;
    }
 }
~~~~~~

* 다음은 유클리드 호제법을 이용하는 방법이다
* a를 b로 나눈 나머지를 r이라고 했을 때
* GCD(a,b) = GCD(b,r)과 같다
* r이 0이면 그 때 b가 최대 공약수이다.
* GCD(24,26) = GCD(16,8) = GCD(8,0) = 8
~~~~~~ 
int gcd(int a, int b) {
  if (b==0) {
    return a;
   } else {
    return;
    }
  }
~~~~~~

### 최소공배수
* 최소공배수는 줄여서 LCM이라고 한다.

### 최대공약수,최소공배수 문제 연습하기.


### 소수
* 소수 : 약수가 1과 자기 자신 밖에 없는 수
* N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
* 1부터 100까지 소수
* EX ) 2,3,5,7,11,13,17,19,89,97

* 소수와 관련된 알고리즘은 두 가지가 있다.
  * 1. 어떤 수 N이 소수인지 아닌지 판별하는 방법
  * 2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법
  
  
~~~~~~
bool prime(int n) {
  if (n < 2) {
    return false;
   }
   for (int i = 2; i<=n-1; i++) {
      if (n % 1 == 0) {
        return false; //소수가 아니다
        }
      }
      return true;
    }
~~~~~~

### 2번째 알고리즘으로 소수 구하기
#### 에라토스테네스의 체
* 지워지지 않은 수 중에서 가장 작은 수는 2이다.
* 2는 소수이고 2의 배수를 모두 지운다.
* 그 다음 작은수 3의 배수를 지운다.
* 반복하면 11의 배수 부터는 이미 지워져 있다.
* 남아있는 모든 수가 소수이다.
  * 에라토스테네스의 체를 사용한 경우
  * 어떤 수 n이 소수인지 아닌지 판별하기 위해 루트 N방법을 사용할 필요가 없다.
  * 에라토스테네스의 결과에서 지워지지 않았으면 소수,아니면 소수가 아니기 때문이다.
~~~~~~
int prime[100]; // 소수저장
int pn = 0; // 소수의 개수
bool check[101]; //지워졌으면 true 아니면 false
int n = 100; // 100까지의 소수
for (int i=2; i<= n; i++) {
  if (check[i] == false) { //지워지지 않음
      prime[pn++] = i;
      for ( int j = i*j; j<=n; j+=i) {
          check[j] = true;
      }
   }
}
~~~~~~
* 1부터 N까지 모든 소수를 구하는 것이 목표이기 때문에, 구현할 때는 바깥 for문 (i)를 N까지 돌린다.

### 소수구하기 문제 연습하기.


### 골드바흐의 추측
* 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다. - 정의
* 위의 문장에 3을 더하면
* 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다.
* 로 바뀐다.
* 아직 증명되지 않은 문제
* 10^18 이하에서는 참인 것이 증명되어 있다.

### 팩토리얼
* 팩토리얼은 매우 큰 값
* 6! = 720
* 10! 3628800

#### 팩토리얼 0의 개수 구하기
* N! = 1 * 2 * ... * N
* 의 0이 몇 개 인지 알아내는 문제
* 10! 이 0이 2개인 이유는 10!을 소인수분해 해보면 알 수 있다.
* 5의 개수를 찾아서 해결
